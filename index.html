<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Looper8+ — Boundary-Accurate Recording</title>
<style>
  :root{--bg:#0b0f0c;--panel:#111718;--ink:#e8f5e9;--muted:#9fb3a9;--line:rgba(255,255,255,.12);
        --g1:#00e676;--g2:#29b6f6;--g3:#ffd54f;--g4:#ff8a65;--g5:#a1887f;--g6:#b39ddb;--g7:#80cbc4;--g8:#ffcc80;
        --rec:#ff5252;--ledOff:#18302b}
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:14px}
  h1{margin:4px 0 8px;font-size:18px}
  .card{background:linear-gradient(180deg,#111718,#0e1416);border:1px solid var(--line);border-radius:12px;padding:10px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .spacer{flex:1}
  .btn{padding:8px 10px;border-radius:10px;border:1px solid var(--line);background:#152325;color:#e8f5e9;font-weight:700;cursor:pointer;font-size:14px}
  .btn.red{background:#3a1717}.btn.green{background:#10371f}.btn.gray{background:#1a1f20}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .small{padding:6px 8px;font-size:12px}
  .num,select{padding:6px 8px;border-radius:10px;border:1px solid var(--line);background:#0b1314;color:#e8f5e9}
  .num{width:90px}
  .badge{font-size:12px;color:#0b0f0c;background:#cde7df;border:0;padding:3px 7px;border-radius:999px;font-weight:800}
  .hint{color:#9fb3a9;font-size:12px}

  .tracks{display:grid;grid-template-columns:1fr;gap:8px;margin-top:10px}
  .track{display:grid;grid-template-columns:70px 1fr auto;gap:8px;align-items:center;background:#0b1314;border:1px solid var(--line);border-radius:12px;padding:8px}
  .tlabel{font-weight:800;font-size:12px;color:#0b0f0c;padding:5px 0;border-radius:10px;text-align:center}
  .c1{background:var(--g1)} .c2{background:var(--g2)} .c3{background:var(--g3)} .c4{background:var(--g4)}
  .c5{background:var(--g5)} .c6{background:var(--g6)} .c7{background:var(--g7)} .c8{background:var(--g8)}

  .mid{display:grid;grid-template-columns:1fr;gap:6px}
  .leds{display:grid;grid-template-columns:repeat(16,1fr);gap:3px}
  .led{height:10px;border-radius:4px;background:var(--ledOff);opacity:.45;transition:opacity .05s ease, filter .05s ease}
  .led.on{opacity:1;filter:brightness(1.8)}
  .bar{height:12px;border-radius:8px;background:#13201d;position:relative;overflow:hidden;border:1px solid var(--line)}
  .fill{position:absolute;left:0;top:0;bottom:0;width:0;background:rgba(255,255,255,.18);transition:background-color .05s}
  .fill.rec{background:rgba(255,82,82,.35)}

  .ctrls{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
  .vol{width:90px}
  .status{font-size:12px;color:#9fb3a9}
  .chip{font-size:11px;border:1px solid var(--line);border-radius:999px;padding:2px 8px}
  .chip.rec{background:#3a1717;color:#ffdcdc;border-color:#5d2020}
  .chip.arm{background:#2a2a10;color:#fff4a3;border-color:#5c5c24}
  .chip.idle{background:#182226;color:#b8d1c6;border-color:#2b3a3a}

  .meterWrap{display:flex;align-items:center;gap:8px}
  .meterBar{width:120px;height:10px;border-radius:6px;background:#1a2422;overflow:hidden;border:1px solid var(--line)}
  .meterFill{height:100%;width:0;background:#2bd17e}

  @media (max-width:720px){
    .track{grid-template-columns:60px 1fr}
    .ctrls{grid-column:1/-1}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Looper8+ — Boundary-Accurate Recording</h1>

  <div class="card">
    <div class="row">
      <button id="initBtn" class="btn green">Enable Audio + Mic</button>
      <button id="playBtn" class="btn gray" disabled>Play</button>
      <button id="stopBtn" class="btn red" disabled>Stop</button>
      <span class="spacer"></span>

      <label class="row">
        <span class="hint">Loop (s)</span>
        <input id="loopLen" class="num" type="number" min="0.5" step="0.1" value="2.0"/>
        <select id="fitMode">
          <option value="trim">Trim/Pad (no pitch)</option>
          <option value="scale">Time-Scale (pitchy)</option>
        </select>
        <button id="applyLoop" class="btn small">Set</button>
      </label>

      <span id="loopBadge" class="badge" style="display:none">Loop: — s</span>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="exportMix"  class="btn small" disabled title="Disabled until at least one recorded track exists">Export Mixdown (WAV)</button>
      <button id="exportStems" class="btn small" disabled title="Disabled until at least one recorded track exists">Export Stems (WAV)</button>
      <button id="saveSess"    class="btn small">Save Session</button>
      <button id="loadSess"    class="btn small">Load Session</button>
      <span id="toast" class="hint" style="margin-left:8px"></span>
      <span class="spacer"></span>
      <label class="row">
        <input id="monitorChk" type="checkbox" disabled/>
        <span class="hint">Monitor input</span>
      </label>
      <div class="meterWrap">
        <span class="hint">Input</span>
        <div class="meterBar"><div id="meterFill" class="meterFill"></div></div>
      </div>
    </div>
  </div>

  <div id="tracks" class="tracks"></div>
</div>

<script>
(() => {
  // ====== Tunables (fix short cuts & multi-click) ======
  const PRE_ROLL_MS   = 120; // start recording a bit BEFORE boundary
  const TAIL_MS       = 60;  // keep recording a bit AFTER boundary
  const NO_LOOP_STOP_GRACE_MS = 80; // manual stop tail

  // ====== State ======
  const N = 8, LED_CELLS = 16;
  let audioCtx = null, mediaStream = null, mediaRec = null;
  let recordingTrack = -1, chunks = [];
  let loopLenSec = null, playing = false, startAt = 0;
  let inputNode = null, analyser = null, monitorGain = null;
  let recBusy = false;
  let recSchedule = null; // { track, startAtCtx, stopAtCtx, boundaryAtCtx }

  const tracks = Array.from({length:N}, (_,i)=>({
    i, label:'T'+(i+1), colorClass:'c'+(i+1),
    buffer:null, source:null, gainNode:null,
    muted:false, solo:false, leds:[], progressEl:null, statusEl:null, recChip:null
  }));

  // ====== DOM ======
  const tEl = document.getElementById('tracks');
  const initBtn = document.getElementById('initBtn');
  const playBtn = document.getElementById('playBtn');
  const stopBtn = document.getElementById('stopBtn');
  const loopLenInput = document.getElementById('loopLen');
  const applyLoopBtn = document.getElementById('applyLoop');
  const fitModeSel = document.getElementById('fitMode');
  const loopBadge = document.getElementById('loopBadge');
  const exportMixBtn = document.getElementById('exportMix');
  const exportStemsBtn = document.getElementById('exportStems');
  const saveSessBtn = document.getElementById('saveSess');
  const loadSessBtn = document.getElementById('loadSess');
  const monitorChk = document.getElementById('monitorChk');
  const meterFill = document.getElementById('meterFill');
  const toastEl = document.getElementById('toast');

  // ====== UI Build ======
  function buildUI(){
    tEl.innerHTML = '';
    tracks.forEach(tr=>{
      const row = document.createElement('div'); row.className='track';

      const tag = document.createElement('div'); tag.className='tlabel '+tr.colorClass; tag.textContent=tr.label;
      row.appendChild(tag);

      const mid = document.createElement('div'); mid.className='mid';
      const leds = document.createElement('div'); leds.className='leds';
      tr.leds = [];
      for (let k=0;k<LED_CELLS;k++){ const d=document.createElement('div'); d.className='led'; leds.appendChild(d); tr.leds.push(d); }
      mid.appendChild(leds);

      const bar = document.createElement('div'); bar.className='bar';
      const fill = document.createElement('div'); fill.className='fill'; bar.appendChild(fill);
      tr.progressEl = fill;
      mid.appendChild(bar);
      row.appendChild(mid);

      const ctrls = document.createElement('div'); ctrls.className='ctrls';
      const recBtn = document.createElement('button'); recBtn.className='btn small'; recBtn.textContent='Rec'; recBtn.disabled = true;
      const stopRecBtn = document.createElement('button'); stopRecBtn.className='btn small red'; stopRecBtn.textContent='Stop Rec'; stopRecBtn.disabled = true;
      const clrBtn = document.createElement('button'); clrBtn.className='btn small'; clrBtn.textContent='Clear'; clrBtn.disabled = true;
      const muteBtn = document.createElement('button'); muteBtn.className='btn small'; muteBtn.textContent='Mute'; muteBtn.disabled = true;
      const soloBtn = document.createElement('button'); soloBtn.className='btn small'; soloBtn.textContent='Solo'; soloBtn.disabled = true;
      const vol = document.createElement('input'); vol.className='vol'; vol.type='range'; vol.min=0; vol.max=1; vol.step=0.01; vol.value=0.9; vol.disabled = true;
      const chip = document.createElement('span'); chip.className='chip idle'; chip.textContent='Idle';

      ctrls.append(recBtn, stopRecBtn, clrBtn, muteBtn, soloBtn, vol, chip);
      row.appendChild(ctrls);

      const status = document.createElement('div'); status.className='status'; status.textContent='—';
      row.appendChild(status);

      tr.statusEl = status; tr.recChip = chip;

      recBtn.addEventListener('click', ()=> safeRecordStart(tr.i, recBtn, stopRecBtn));
      stopRecBtn.addEventListener('click', ()=> stopRecording());
      clrBtn.addEventListener('click', ()=> clearTrack(tr.i));
      muteBtn.addEventListener('click', ()=> toggleMute(tr.i, muteBtn));
      soloBtn.addEventListener('click', ()=> toggleSolo(tr.i, soloBtn));
      vol.addEventListener('input', e=> setVolume(tr.i, Number(e.target.value)));

      tEl.appendChild(row);
    });
  }
  buildUI();

  function enableTrackControls(on){
    document.querySelectorAll('.ctrls .btn').forEach(b=>{
      const label = b.textContent;
      if (label==='Rec') b.disabled = !on || !mediaRec;
      else if (label==='Stop Rec') b.disabled = true;
      else b.disabled = !on;
    });
    document.querySelectorAll('.vol').forEach(v=> v.disabled = !on);
  }

  // ====== Core guards ======
  async function ensureAudioReady(){
    if (!audioCtx){ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    if (audioCtx.state === 'suspended'){ try{ await audioCtx.resume(); }catch{} }
  }
  async function ensureMicAndRecorder(){
    if (!mediaStream){
      try{
        mediaStream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true,noiseSuppression:true}, video:false});
      }catch(e){
        toast('Mic denied. Allow mic to record.');
        return false;
      }
    }
    if (!mediaRec){
      const mime = getBestMime();
      if (!mime){ toast('MediaRecorder not supported in this browser.'); return false; }
      mediaRec = new MediaRecorder(mediaStream, {mimeType: mime});
      mediaRec.ondataavailable = (e)=> { if (e.data && e.data.size) chunks.push(e.data); };
      mediaRec.onstop = onRecordingComplete;

      inputNode = audioCtx.createMediaStreamSource(mediaStream);
      analyser = audioCtx.createAnalyser(); analyser.fftSize = 512; analyser.smoothingTimeConstant = 0.85;
      monitorGain = audioCtx.createGain(); monitorGain.gain.value = 0.0;
      inputNode.connect(analyser); analyser.connect(monitorGain); monitorGain.connect(audioCtx.destination);
      monitorChk.disabled = true; // keep off by default to avoid feedback
      tickMeter();
    }
    return true;
  }

  // ====== Init / Transport ======
  initBtn.addEventListener('click', async ()=>{
    await ensureAudioReady();
    const ok = await ensureMicAndRecorder();
    tracks.forEach(tr=>{ if (!tr.gainNode){ const g=audioCtx.createGain(); g.gain.value=0.9; g.connect(audioCtx.destination); tr.gainNode=g; }});
    playBtn.disabled = false; stopBtn.disabled = false;
    enableTrackControls(true);
    initBtn.disabled = true; initBtn.textContent = ok ? 'Audio Ready' : 'Audio (no recorder)';
  });

  playBtn.addEventListener('click', async ()=>{
    await ensureAudioReady();
    if (!loopLenSec){ const v = Math.max(0.5, Number(loopLenInput.value)||0); loopLenSec = v; setLoopLenDisplay(); }
    startPlayback();
  });
  stopBtn.addEventListener('click', stopPlayback);

  function startPlayback(){
    if (playing || !loopLenSec) return;
    const t0 = audioCtx.currentTime + 0.08;
    tracks.forEach(tr=>{
      if (tr.source){ try{ tr.source.stop(); }catch{} tr.source.disconnect(); tr.source=null; }
      if (!tr.buffer) return;
      const buf = normalizeToLoop(tr.buffer, loopLenSec);
      const src = audioCtx.createBufferSource();
      src.buffer = buf; src.loop = true; src.loopStart = 0; src.loopEnd = loopLenSec;
      src.connect(tr.gainNode);
      src.start(t0);
      tr.source = src;
    });
    startAt = t0; playing = true; tickProgress();
  }
  function stopPlayback(){
    if (!playing) return;
    tracks.forEach(tr=>{
      if (tr.source){ try{ tr.source.stop(); }catch{} tr.source.disconnect(); tr.source=null; }
      if (tr.progressEl) tr.progressEl.style.width='0%';
      tr.leds.forEach(d=>d.classList.remove('on'));
    });
    playing = false;
  }

  // ====== Recording (boundary-accurate) ======
  async function safeRecordStart(i, recBtn, stopRecBtn){
    if (recBusy) return; recBusy = true;

    tr(i).recChip.className='chip arm';
    tr(i).recChip.textContent='Arming…';

    await ensureAudioReady();
    const ok = await ensureMicAndRecorder();
    if (!ok){ tr(i).recChip.className='chip idle'; tr(i).recChip.textContent='Idle'; recBusy=false; return; }

    // UI lock
    recBtn.disabled = true; stopRecBtn.disabled = false;
    recordingTrack = i; chunks = [];
    tr(i).statusEl.textContent = 'Recording…';
    tr(i).progressEl.classList.add('rec');
    tr(i).recChip.className='chip rec'; tr(i).recChip.textContent='REC';

    if (loopLenSec && playing){
      const now = audioCtx.currentTime;
      const elapsed = (now - startAt) % loopLenSec;
      let timeToBoundary = loopLenSec - elapsed;
      if (timeToBoundary < PRE_ROLL_MS/1000 + 0.04) timeToBoundary += loopLenSec;

      const boundaryAt = now + timeToBoundary;
      const startAtCtx = boundaryAt - (PRE_ROLL_MS/1000);
      const stopAtCtx  = boundaryAt + loopLenSec + (TAIL_MS/1000);
      recSchedule = { track: i, startAtCtx, stopAtCtx, boundaryAtCtx: boundaryAt };

      waitUntil(startAtCtx, async () => {
        if (!mediaRec) return endRecUI(i);
        try { mediaRec.start(); } catch(e){ toast('Recorder failed to start.'); return endRecUI(i); }
        sweepRecordLEDs(i);
      });

      waitUntil(stopAtCtx, () => {
        if (mediaRec && mediaRec.state === 'recording') {
          try { if (mediaRec.requestData) mediaRec.requestData(); } catch {}
          mediaRec.stop();
        }
      });

    } else {
      try { mediaRec.start(); } catch(e){ toast('Recorder failed to start.'); endRecUI(i); recBusy=false; return; }
      sweepRecordLEDs(i);
    }

    recBusy = false;
  }

  function stopRecording(){
    if (!mediaRec || mediaRec.state !== 'recording') return;
    const t = audioCtx.currentTime;
    waitUntil(t + NO_LOOP_STOP_GRACE_MS/1000, () => {
      try { if (mediaRec.requestData) mediaRec.requestData(); } catch {}
      mediaRec.stop();
    });
  }

  function waitUntil(whenCtxTime, fn){
    const tick = ()=>{
      if (!audioCtx) return;
      if (audioCtx.currentTime >= whenCtxTime - 0.001) { fn(); return; }
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
  }

  async function onRecordingComplete(){
    const i = recordingTrack; recordingTrack = -1;
    tr(i).recChip.className='chip idle'; tr(i).recChip.textContent='Idle';

    const blob = new Blob(chunks, {type: chunks[0]?.type || 'audio/webm'});
    let ab; try { ab = await blob.arrayBuffer(); } catch { endRecUI(i); return; }
    let buf = await audioCtx.decodeAudioData(ab).catch(()=>null);
    if (!buf){ toast('Decode failed. Try Chrome/Edge.'); endRecUI(i); return; }

    buf = toMonoWithFades(buf, 0.004);

    if (recSchedule && recSchedule.track === i){
      const sr = buf.sampleRate;
      const pre  = Math.floor((PRE_ROLL_MS/1000) * sr);
      const want = Math.floor(loopLenSec * sr);
      let data = buf.getChannelData(0);
      const headTrim = Math.min(pre, data.length);
      data = data.subarray(headTrim);
      const out = audioCtx.createBuffer(1, want, sr);
      const o = out.getChannelData(0);
      const n = Math.min(want, data.length);
      o.set(data.subarray(0, n), 0);
      buf = out;
      recSchedule = null;
    } else {
      if (!loopLenSec){
        loopLenSec = Math.max(0.5, Number(loopLenInput.value)||buf.duration);
        setLoopLenDisplay();
      }
      buf = fitBufferToLoop(buf, loopLenSec);
    }

    tracks[i].buffer = buf;
    tr(i).statusEl.textContent = 'Ready ('+buf.duration.toFixed(2)+'s)';

    exportMixBtn.disabled = false; exportMixBtn.removeAttribute('title');
    exportStemsBtn.disabled = false; exportStemsBtn.removeAttribute('title');

    if (playing){
      if (tr(i).source){ try{ tr(i).source.stop(); }catch{} tr(i).source.disconnect(); }
      const src = audioCtx.createBufferSource();
      src.buffer = normalizeToLoop(buf, loopLenSec); src.loop=true; src.loopStart=0; src.loopEnd=loopLenSec;
      src.connect(tr(i).gainNode);
      const now = audioCtx.currentTime; const elapsed=(now-startAt)%loopLenSec;
      src.start(now, elapsed); tr(i).source = src;
    }
    endRecUI(i);
  }

  function endRecUI(i){
    document.querySelectorAll('.ctrls .btn').forEach(b=>{
      if (b.textContent==='Stop Rec') b.disabled = true;
      if (b.textContent==='Rec') b.disabled = !mediaRec;
    });
    const f = tr(i).progressEl; if (f) f.classList.remove('rec');
  }

  function sweepRecordLEDs(i){
    const r = tr(i);
    const tick = ()=>{
      if (!mediaRec || mediaRec.state!=='recording'){ r.leds.forEach(d=>d.classList.remove('on')); return; }
      const now = audioCtx.currentTime;
      const frac = loopLenSec ? ((now - startAt) % loopLenSec) / loopLenSec : ((now*1.0) % 1.0);
      const pos = Math.floor(frac * LED_CELLS) % LED_CELLS;
      r.leds.forEach((d, idx)=> d.classList.toggle('on', idx===pos));
      requestAnimationFrame(tick);
    };
    tick();
  }

  // ====== Track ops ======
  function tr(i){ return tracks[i]; }
  function clearTrack(i){
    const t = tr(i);
    if (t.source){ try{ t.source.stop(); }catch{} t.source.disconnect(); t.source=null; }
    t.buffer = null; t.statusEl.textContent = '—';
    t.progressEl.style.width='0%'; t.leds.forEach(d=>d.classList.remove('on'));
    if (!tracks.some(x=>x.buffer)){ loopLenSec = null; setLoopLenDisplay(); exportMixBtn.disabled = true; exportStemsBtn.disabled = true; }
  }
  function toggleMute(i, btn){ const t=tr(i); t.muted=!t.muted; refreshGains(); btn.textContent = t.muted ? 'Unmute':'Mute'; }
  function toggleSolo(i, btn){ const t=tr(i); t.solo=!t.solo; refreshGains(); btn.textContent = t.solo ? 'Unsolo':'Solo'; }
  function setVolume(i, v){
    const t=tr(i); if (!t.gainNode) return;
    t.gainNode.gain.value = v * (t.muted ? 0 : 1) * (anySolo() ? (t.solo?1:0) : 1);
  }
  function anySolo(){ return tracks.some(t=>t.solo); }
  function refreshGains(){
    const soloMode = anySolo();
    document.querySelectorAll('.tracks .track').forEach((row, idx)=>{
      const vol = Number(row.querySelector('.vol').value)||1;
      const t = tr(idx); const gate = t.muted ? 0 : (soloMode ? (t.solo?1:0) : 1);
      if (t.gainNode) t.gainNode.gain.value = vol * gate;
    });
  }

  // ====== Loop utils ======
  applyLoopBtn.addEventListener('click', async ()=>{
    await ensureAudioReady();
    const newLen = Math.max(0.5, Number(loopLenInput.value)||0);
    if (!loopLenSec){ loopLenSec = newLen; setLoopLenDisplay(); return; }
    const conformed = tracks.map(t=> t.buffer ? fitOrScale(t.buffer, newLen, fitModeSel.value) : null);
    tracks.forEach((t,idx)=>{
      if (!conformed[idx]) return;
      t.buffer = conformed[idx];
      if (playing){
        if (t.source){ try{ t.source.stop(); }catch{} t.source.disconnect(); }
        const src = audioCtx.createBufferSource();
        src.buffer = normalizeToLoop(t.buffer, newLen); src.loop=true; src.loopEnd=newLen;
        src.connect(t.gainNode);
        const now=audioCtx.currentTime, elapsed=(now-startAt)%newLen;
        src.start(now, elapsed); t.source = src;
      }
    });
    loopLenSec = newLen; setLoopLenDisplay();
  });

  function setLoopLenDisplay(){
    if (!loopLenSec){ loopBadge.style.display='none'; return; }
    loopBadge.style.display='inline-block';
    loopBadge.textContent = 'Loop: ' + loopLenSec.toFixed(2) + ' s';
    loopLenInput.value = loopLenSec.toFixed(2);
  }

  // ====== Export ======
  exportMixBtn.addEventListener('click', async ()=>{
    if (!hasAudio()) { toast('Record something first.'); return; }
    const sr = audioCtx?.sampleRate || 44100;
    const len = Math.floor(loopLenSec * sr);
    const off = new OfflineAudioContext(1, len, sr);
    tracks.forEach(t=>{
      if (!t.buffer) return;
      const src = off.createBufferSource();
      src.buffer = normalizeToLoop(t.buffer, loopLenSec);
      src.loop = true; src.loopStart=0; src.loopEnd=loopLenSec;
      const g = off.createGain();
      const vol = getVolForIndex(t.i);
      const gate = t.muted ? 0 : (anySolo() ? (t.solo?1:0) : 1);
      g.gain.value = vol * gate;
      src.connect(g).connect(off.destination);
      src.start(0);
    });
    const rendered = await off.startRendering();
    downloadWav(rendered, `looper8_mix_${loopLenSec.toFixed(2)}s.wav`);
  });

  exportStemsBtn.addEventListener('click', ()=>{
    if (!hasAudio()) { toast('Record something first.'); return; }
    tracks.forEach((t, idx)=>{
      if (!t.buffer) return;
      const b = normalizeToLoop(t.buffer, loopLenSec);
      downloadWav(b, `looper8_t${idx+1}_${loopLenSec.toFixed(2)}s.wav`);
    });
  });

  function hasAudio(){ return !!loopLenSec && tracks.some(t=>t.buffer); }
  function getVolForIndex(i){
    const row = document.querySelectorAll('.tracks .track')[i];
    return row ? Number(row.querySelector('.vol').value)||1 : 1;
  }

  function downloadWav(buffer, filename){
    const wav = encodeWAV(buffer);
    const blob = new Blob([wav], {type:'audio/wav'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
    setTimeout(()=> URL.revokeObjectURL(a.href), 1000);
  }
  function encodeWAV(buffer){
    const numCh=1, sr=buffer.sampleRate, data=buffer.getChannelData(0), len=data.length;
    const bytes = new ArrayBuffer(44 + len*2);
    const view = new DataView(bytes);
    const W=(o,s)=>{ for(let i=0;i<s.length;i++) view.setUint8(o+i,s.charCodeAt(i)); }
    W(0,'RIFF'); view.setUint32(4,36+len*2,true); W(8,'WAVE'); W(12,'fmt '); view.setUint32(16,16,true);
    view.setUint16(20,1,true); view.setUint16(22,numCh,true); view.setUint32(24,sr,true);
    view.setUint32(28,sr*numCh*2,true); view.setUint16(32,numCh*2,true); view.setUint16(34,16,true);
    W(36,'data'); view.setUint32(40,len*2,true);
    let off=44; for (let i=0;i<len;i++){ let s=Math.max(-1,Math.min(1,data[i])); view.setInt16(off, s<0?s*0x8000:s*0x7fff, true); off+=2; }
    return view;
  }

  // ====== DSP utils ======
  function toMonoWithFades(buf, fadeSec=0.003){
    const ch = buf.numberOfChannels, len = buf.length, out = audioCtx.createBuffer(1, len, buf.sampleRate);
    const o = out.getChannelData(0);
    if (ch===1){ o.set(buf.getChannelData(0)); }
    else{
      const a=buf.getChannelData(0), b=buf.getChannelData(1);
      for (let i=0;i<len;i++) o[i] = 0.5*(a[i]+b[i]);
    }
    const f = Math.max(1, Math.floor(fadeSec * out.sampleRate));
    for (let k=0;k<f;k++){ const t=k/f; o[k]*=t; o[len-1-k]*=t; }
    return out;
  }
  function fitBufferToLoop(buf, loopLen){
    const sr = buf.sampleRate, want = Math.floor(loopLen * sr);
    const out = audioCtx.createBuffer(1, want, sr);
    const o = out.getChannelData(0); const iData = buf.getChannelData(0);
    const n = Math.min(want, buf.length); o.set(iData.subarray(0,n), 0);
    const f = Math.max(1, Math.floor(0.003 * sr));
    for (let i=0;i<f;i++){ const t=i/f; o[want-1-i]*=t; }
    return out;
  }
  function fitOrScale(buf, newLen, mode){
    if (mode==='trim') return fitBufferToLoop(buf, newLen);
    const ratio = newLen / buf.duration;
    const sr = buf.sampleRate, outLen = Math.max(1, Math.floor(buf.length * ratio));
    const out = audioCtx.createBuffer(1, outLen, sr);
    const o = out.getChannelData(0), i = buf.getChannelData(0);
    for (let n=0;n<outLen;n++){
      const x = n / ratio; const i0 = Math.floor(x), i1 = Math.min(buf.length-1, i0+1); const f = x - i0;
      o[n] = i[i0]*(1-f) + i[i1]*f;
    }
    const F = Math.max(1, Math.floor(0.003 * sr));
    for (let k=0;k<F;k++){ const t=k/F; o[k]*=t; o[outLen-1-k]*=t; }
    return out;
  }
  function normalizeToLoop(buf, loopLen){
    return Math.abs(buf.duration - loopLen) < 1e-3 ? buf : fitBufferToLoop(buf, loopLen);
  }

  // ====== Meter & Progress ======
  function tickProgress(){
    if (!playing || !loopLenSec) return;
    const now = audioCtx.currentTime, frac = ((now - startAt) % loopLenSec) / loopLenSec;
    const pos = Math.floor(frac * LED_CELLS) % LED_CELLS;
    tracks.forEach(tr=>{
      if (tr.progressEl) tr.progressEl.style.width = (frac*100).toFixed(1)+'%';
      if (tr.leds) tr.leds.forEach((d, idx)=> d.classList.toggle('on', idx===pos));
    });
    requestAnimationFrame(tickProgress);
  }
  function tickMeter(){
    if (!analyser) return;
    const arr = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(arr);
    let sum=0; for (let i=0;i<arr.length;i++){ const v=(arr[i]-128)/128; sum += v*v; }
    const rms = Math.sqrt(sum/arr.length); const pct = Math.min(100, Math.max(0, rms*140*100));
    meterFill.style.width = pct.toFixed(0)+'%';
    requestAnimationFrame(tickMeter);
  }

  // ====== Helpers ======
  function getBestMime(){
    const cands = ['audio/webm;codecs=opus','audio/webm','audio/mp4','audio/ogg;codecs=opus'];
    for (const m of cands){ if (window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m; }
    return '';
  }
  function toast(msg){ toastEl.textContent = msg; setTimeout(()=> toastEl.textContent='', 2500); }
})();
</script>
</body>
</html>
